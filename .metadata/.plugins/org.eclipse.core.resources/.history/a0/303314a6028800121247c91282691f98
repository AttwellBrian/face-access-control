
public class PlanSomething {

	public static void main(String args[]) {
		
		//TODO: Check return values
		
		/*
Test Requirement: [1,2,5,8,9,10]
Test Path: [1,2,5,8,9,10]
Input: computeIntersection(new float[] {0,0}, new float[] {1,5}, new float[] {0,0}, new float[] {1,4});
Return: new float[] {0,0}
*/
		// alpha1 > 4000, alpha2 > 4000 && ....
	//	computeIntersection(new float[] {0,0}, new float[] {1,5}, new float[] {0,0}, new float[] {1,4});
		/*

Test Requirement: [1,2,5,8,10]
Test Path: 
Input: computeIntersection(new float[] {0,0}, new float[] {1,5}, new float[] {0,0}, new float[] {1,(float) (5+1E-6)});
Return: 
*/
		//computeIntersection(new float[] {0,0}, new float[] {1,5}, new float[] {0,0}, new float[] {1,(float) (5+1E-6)});
		/*
Test Requirement: [1,2,5,6,7,10]
Test Path: [1,2,5,6,7,10]
Input: computeIntersection(new float[] {0,0}, new float[] {1,5}, new float[] {0,0}, new float[] {1,4001});
Return: 
*/
		//computeIntersection(new float[] {0,0}, new float[] {1,5}, new float[] {0,0}, new float[] {1,4001});
		
		
		/*
Test Requirement: [1,2,5,6,10]
Test Path: [1,2,5,6,10]
Input: computeIntersection(new float[] {0,0}, new float[] {1,4000}, new float[] {0,0}, new float[] {1,4001});
Return: 
*/
		//computeIntersection(new float[] {0,0}, new float[] {1,4000}, new float[] {0,0}, new float[] {1,4001});
		
		/*
Test Requirement: [1,2,3,4,10]
Test Path: 
Input: 
Return: 
*/
	computeIntersection(new float[] {0,0}, new float[] {1,4001}, new float[] {0,0}, new float[] {1,4001});
		/*
Test Requirement: [1,2,3,10]
Test Path: [1,2,3,10]
Input: computeIntersection(new float[] {0,0}, new float[] {1,100001}, new float[] {0,0}, new float[] {1,100000});
Return: new float[] {1,100001}
*/
		//computeIntersection(new float[] {0,0}, new float[] {1,100001}, new float[] {0,0}, new float[] {1,100000});
		/*
Test Requirement: [1,10]
Test Path: [1,10]
Input: computeIntersection(new float[] {0,0}, new float[] {0,100000}, new float[] {0,0}, new float[] {0,100000});
Return: new float[] {0, 10000} 
*/
		//computeIntersection(new float[] {0,0}, new float[] {0,100000}, new float[] {0,0}, new float[] {0,100000});
  
	}
	
	private static float [] computeIntersection(float [] point1, float [] point2, float [] point3, float [] point4) {
	    float x = point2 [0];
	    float y = point2 [1];
	    float alpha1 = (point2 [1] - point1 [1]) / (point2 [0] - point1 [0]);
	    float alpha2 = (point4 [1] - point3 [1]) / (point4 [0] - point3 [0]);
	    if (alpha1 != alpha2) {
	      // If first line is vertical
	      if (Math.abs(alpha1) > 4000)  {
	        if (Math.abs(alpha2) < 4000) {
	          x = point1 [0];
	          float beta2 = point4 [1] - alpha2 * point4 [0];
	          y = alpha2 * x + beta2;
	        }
	        // If second line is vertical
	      } else if (Math.abs(alpha2) > 4000) {
	        if (Math.abs(alpha1) < 4000) {
	          x = point3 [0];
	          float beta1 = point2 [1] - alpha1 * point2 [0];
	          y = alpha1 * x + beta1;
	        }
	      } else { 
	        boolean sameSignum = Math.signum(alpha1) == Math.signum(alpha2);
	        if ((sameSignum && (Math.abs(alpha1) > Math.abs(alpha2)   ? alpha1 / alpha2   : alpha2 / alpha1) > 1.0001)
	            || (!sameSignum && Math.abs(alpha1 - alpha2) > 1E-5)) {
	          float beta1 = point2 [1] - alpha1 * point2 [0];
	          float beta2 = point4 [1] - alpha2 * point4 [0];
	          x = (beta2 - beta1) / (alpha1 - alpha2);
	          y = alpha1 * x + beta1;
	        }
	      }
	    }
	    return new float [] {x, y};
	  }

	
}
